# JVM

![jvm](https://raw.githubusercontent.com/xuyangliu/ShareYourLearning/master/ProgrammingLanguage/Java/images/jvm.jpg)

## 1. 类加载器子系统（Class Loader Subsystem）
> Java的动态类加载功能是由类加载器子系统处理。当它在运行时（不是编译时）首次引用一个类时，它加载、链接并初始化该类文件。

### 1.1 加载（Loading）

#### 1.1.1 类加载组件

1.  **启动类加载器(BootStrap class Loader)** – 由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类；**这个加载器会被赋予最高优先级**。
2.  **扩展类加载器(Extension class Loader)** – 主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3.  **应用程序类加载器(Application class Loader)** – 面向用户的加载器，负责加载当前应用`classpath`下的所有jar包和类。
-  主要完成下面3件事情：
    1. 通过全类名获取定义此类的class文件。
    2. 将class文件中所相关的二进制数据存储到方法区。
    3. 在堆内存中生成一个代表该类的 Class 对象。

#### 1.1.2 委托层次算法（Delegation Hierarchy Algorithm）

​		 JVM逐行执行java程序。每当JVM首先遇到一个特定的类时，JVM将检查这个.class文件是否已经加载，如果已经加载，JVM会从方法区加载这个类，否则JVM将请求类加载器子系统装入.class文件，然后类加载器子系统将该请求发送给应用程序类装入器。

![class_loader](https://raw.githubusercontent.com/xuyangliu/ShareYourLearning/master/ProgrammingLanguage/Java/images/class_loader.png)

**自底向上检查类是否被加载过**

- 应用程序类加载器不会加载请求的类，只是将其委托给扩展类加载器。

- 扩展类加载器也不会加载请求的类，只是委托启动类加载器。

**自顶向下尝试去加载类**

- 启动类加载器在启动类路径中搜索，如果找到该类，则加载它，否则将其委托给扩展类加载器；
- 扩展类加载器在扩展类路径中搜索，如果找到该类，则加载它，否则将其委托给应用程序类加载器；
- 应用程序类加载器在应用程序类路径中搜索。如果找到该类，则加载它，否则将得到运行时异常，称为“ClassNotFound”异常。
- 假设启动类加载器找不到，扩展类加载器找不到，应用程序类加载器找不到，那么我们将得到运行时异常，称为“**ClassNotFound**”异常。

#### 1.1.3 定制类加载器

​		有时不满足于使用默认的类加载器机制，然后我们可以去定制类加载器。

​		默认的类加载器只加载一次.class文件，即使我们在程序中多次使用该类。如果在外部修改了.class文件，那么默认的类加载器将不会动态加载.class文件的更新版本，因为.class文件已经在方法区域中了。为了克服这个问题，我们将使用定制的类装入器。

​		每当我们使用类时，自定义类加载器检查是否有更新的版本可用。如果它是可用的，然后加载更新的版本，否则使用已加载的现有.class文件，使更新的版本可用到我们的程序。

### 1.2 链接（Linking）

#### 1.2.1 校验（Verification）

​		校验器会校验生成文件的格式规范、元数据、字节码、符号引用，如果校验失败，会得到校验错误。
- 文件格式的验证：是否符合Class文件的规范，以及能够被当前版本的虚拟机处理。
    - 是否以0xCAFEBABE开头。
    - 主、次版本是否在当前虚拟机处理的范围之内。
    - 常量池的常量是否有不支持的常量类型。
    > 主要的目的是保证输入的字节流能够正确的解析并存储于方法区之内，格式上符合一个java类型信息的要求。只有通过这个阶段的验证，虚拟机才会让字节流进入到方法区中进行存储，后面的验证都是直接操作在方法区之上，而不是直接操作字节流。
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述符合java语言规范的要求。
    - 这个类是否有父类，java中除了Object，其它的类必须存在父类，默认为Object。
    - 这个类是否extends了不被允许的类，如被final修饰的类。
    - 如果这个类不是抽象类，是否实现了其父类或接口之中需要实现的所有方法。
    - 类中的字段、方法是否与父类产生矛盾，如覆盖了父类的final字段和方法，覆盖不符合规则等等。
- 字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。主要对方法进行验证，防止方法在运行时，不会做出对虚拟机有危害的操作。
    - 保证任意时刻操作数栈的数据类型与指令码序列都能够配合工作，不会出现类似，在操作栈放置了一个int类型的数据，使用时却按long类型来载入本地变量表中。
    - 保证跳转指令不会跳到方法体以外的字节码指令上。
    - 保证类型转换是有效的，例如把父类型赋值给子类型是安全的，子类型赋值给父类型就是不安全危险的。

#### 1.2.2 准备（Preparation）

​		正式分配内存并初始化**零值**给所有的**静态变量**。内存分配不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。

![zero_value](https://raw.githubusercontent.com/xuyangliu/ShareYourLearning/master/ProgrammingLanguage/Java/images/zero_value.png)

​		**内存分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

> **内存分配并发问题（补充内容，需要掌握）**
>
> 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
>
> - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
> - **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### 1.2.3 解析（Resolution）

​		将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行，也就是得到类或者字段、方法在内存中的指针或者偏移量。

- **符号引用**就是一组符号来描述目标，可以是任何字面量。

- **直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

> ​		在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。
>
> ​		Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。


### 1.3 初始化（Initialization）

​		类加载的最后阶段，执行`<clinit>()` 包方法，所有的静态变量会被赋**初始值**，并且静态块将被执行，一个真正可用的对象才算完全产生出来。

​		对于初始化阶段，虚拟机严格规范了有且只有5种情况下，必须对类进行初始化：

1. 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. 当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。

> 对于`<clinit>（）` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit>（）` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。

## 2. 执行引擎（Execution Engine）
> 分配给运行时数据区的字节码将由执行引擎执行。执行引擎读取字节码并逐段执行。

### 2.1 解释器（Interpreter）

​		解释器能快速的解释字节码，但执行却很慢。 解释器的缺点就是,当一个方法被调用多次，每次都需要重新解释。

### 2.2 编译器（Compiler）

​		JIT编译器消除了解释器的缺点。执行引擎利用解释器转换字节码，但如果是重复的代码则使用JIT编译器将全部字节码编译成本机代码。本机代码将直接用于重复的方法调用，这提高了系统的性能。

1. 中间代码生成器 – 生成中间代码

2. 代码优化器 – 负责优化上面生成的中间代码

3. 目标代码生成器 – 负责生成机器代码或本机代码

4. 探测器(Profiler) – 一个特殊的组件，负责寻找被多次调用的方法。

### 2.3 垃圾回收器（Garbage Collection）

​		收集并删除未引用的对象。可以通过调用"System.gc()"来触发垃圾回收，但并不保证会确实进行垃圾回收。JVM的垃圾回收只收集哪些由new关键字创建的对象。所以，如果不是用new创建的对象，你可以使用finalize函数来执行清理。

## 3. Java本地接口 (Java Native Interface)

​		JNI 会与本地方法库进行交互并提供执行引擎所需的本地库。

## 4. 本地方法库（Native Method Library）

​		一个执行引擎所需的本地库的集合。

## 5. 运行时数据区（Runtime Data Area）

- **线程共享：**
  - 堆[Heap]
  - 方法区[Method]
- **线程私有：**
  - 虚拟机栈[VM Stack]
  - 本地方法栈[Native Method Stack]
  - 程序计数器[Program Counter Register]

### 5.1 堆（Heap）

​		JVM中最大的一块内存区域，存储着生成的对象、数组等。堆可以被细化为**年轻代[Young Generation]**和**老年代[Old Generation]**，而**年轻代[Young Generation]**又可以分为**Eden**、**From Survivor**、**To Survivor**三个区域，比例是8:1:1，**设置两个Survivor区最大的好处就是解决了碎片化，永远有一个survivor space是空的，另一个非空的survivor space无碎片**。

​		Eden区域是用来存放使用new或者newInstance等方式创建的对象，默认都是存放在Eden区，除非这个对象太大，或者超过了设定的阈值-XX:PretenureSizeThresold,这样的对象会被直接分配到老年代区域。

1. Eden满，执行第一次Minor GC，存活着的对象复制到From Survivor，**若From Survivor也满了，会进行过早提升[Premature promotion]，把剩余对象存放到老年代**。
2. 清空Eden，但此时To Survivor也是空置的。
3. Eden满，执行Minor GC，Eden和From Survivor存活着的对象复制到To Survivor，**若To Survivor也满了，会进行过早提升[Premature promotion]，把剩余对象存放到老年代**，只是这次对象来源区域增加了From Survivor。
4. 清空Eden和From Survivor。
5. From Survivor和To Survivor交换（From 变 To，To 变 From），重复上述2-5过程。
6. 如果某个存活着的对象的复制次数达到16次，该对象就会被送到老年代。
7. **Premature promotion**短期不会有问题， 但经常性的**Premature promotion**， 最终会导致大量短期对象被提升到老年代，老年代空间不足，引发另一个 JVM 内存问题**Promotion failure**（提升失败： 即老年代空间不足以容乃 Minor GC 中提升上来的对象）。**Promotion failure**发生就会让 JVM 进行一次 CMS 垃圾收集进而腾出空间接受新生代提升上来的对象，CMS 垃圾收集时间比Minor GC长，导致吞吐量下降、时延上升。

> **JVM8中把运行时常量池、静态变量也移到堆进行存储**。
>
>  - class文件在编译后除了存储一些类的版本、字段、方法、接口等元数据信息外，还有一部分信息是常量池，这个常量池我们称之为“静态常量池”，只是作为一种持久化数据存储在硬盘上，代表编译期生成的各种字面量和符号引用（最常见的就是字符串常量），那么这类信息被加载到内存中就会以运行时常量池的形式存在内存中，JDK7以前这类信息被存储在方法区，但是JDK7/JDK8都已经移到了堆。
> - 如果堆中已经存在一个数据变量，即使再创建一个这样的变量，那么JVM将会直接指向已经创建好的数据，而不会再分配内存区域，一方面加快数据的创建，另一方面节省内存空间。

No.1 Tip：

- 对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代（Java 7）进行垃圾回收叫做full GC。许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。
- major GC和full GC通常是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是major GC。
- Minor GC 非常频繁，回收速度一般也比较快；Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。

No.2 Tip：

- 对于新生代问题， 如果服务器内存足够用， 建议是直接增大新生代空间(如 -Xmn)。如果内存不够用， 则增加 Survivor 空间， 减少 Eden 空间， 但是注意减少 Eden 空间会增加 Minor GC 频率， 要考虑到应用对延迟和吞吐量的指标最终是否符合。
- 要增大多少 Survivor 空间？ 需要观察多次 Minor GC 过程， 看 Minor GC 后存活下来的对象大小， 最终确定 Survivor 的合适大小。 整个调优过程可能需要几次调整， 才能找到比较合适的值。调整几次后， 如果内存还是不够用， 就要需要考虑增大服务器内存， 或者把负载分担到更多的 JVM 实例上。

1.Survivor存在的意义？
    减少对象直接进入老年代的机会，减少Full GC的频率，从而尽可能减少GC停顿的发生；

2.为什么需要划分两个Survivor出来？
    新生代一般采用复制算法来回收内存，每次内存回收总是需要另一块空的区域（s0或s1,s0、s1轮流被使用）来存放GC存活下来的对象。

### 5.2 方法区（Method）

​		方法区主要是存储类的元数据的，如虚拟机加载的类信息、编译后的代码等。JDK8之前方法区的实现是被称为一种**永久代[Per Gen]**的区域，这部分区域使用JVM内存，但是JDK8的时候便移除了**永久代[Per Gen]**，转而使用**元空间[MetaSpace]**的实现。

​		永久代的调优是很困难的，虽然可以设置永久代的大小，但是很难确定一个合适的大小，因为其中的影响因素很多，比如类数量的多少、常量数量的多少等。永久代中的元数据的位置也会随着一次full GC发生移动，比较消耗虚拟机性能，HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代中的元数据。

​		将**元数据从永久代剥离出来**，不仅实现了对元空间的无缝管理，还可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化；此外元空间不在共用JVM内存，而是使用的系统内存，具体大小理论上取决于32位/64位系统可用内存的大小，也不是无限制的，需要配置参数。

> 元空间的大小仅受本地内存限制，可以通过以下参数来指定元空间大小：
>
> - -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
> - -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
> - -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。
> - -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。
>
> Java8中的JVM PermSize 和 MaxPermSize会被忽略，当前在启动时会有警告信息。

### 5.3 虚拟机栈（VM Stack）

​		虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个**栈帧[Stack Frame]**，每个栈帧对应一次方法调用，栈帧存储**局部变量表、操作栈、动态链接、方法出口等信息**。**虚拟机栈是线程私有的，它的生命周期与线程相同，每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。** 

> ​		局部变量表存放了编译期可知的各种**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和**returnAddress类型**（指向了一条字节码指令的地址）。  
>
> ​		其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 

- Java虚拟机规范中，对这个区域规定了两种异常状况。
  - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
  - 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 

- Java 方法有两种返回方式，不管哪种返回方式都会导致栈帧被弹出。
  - return 语句。
  - 抛出异常。

### 5.4 本地方法栈（Native Method Stack）

​		本地方法栈区域是专门为Native方法来实现的，由于java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。目的是提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节 ，一个Native Method就是一个java调用非java代码的接口。方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。 

​		本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

​		方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError 两种异常。

### 5.5 程序计数器（Program Counter Register）

​		程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

​		在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 

​		由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。** 

- 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。
- 如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。

## 6. 对象生死判断算法

### 6.1 引用计数器（One Reference counting）

​		引用计算器判断对象是否存活的原理：给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加1，与之相反，每当引用失效的时候就减1。

**优点：**实现简单、性能高。

**缺点：**增减处理频繁消耗cpu计算、计数器占用很多位浪费空间、最重要的缺点是无法解决循环引用的问题。因为引用计数器算法很难解决循环引用的问题，所以主流的Java虚拟机都没有使用引用计数器算法来管理内存。

### 6.2 可达性分析（Two Accessibility analysis）

​		可达性分析算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”，当一个对象到GC Roots没有任何引用链相连的时候，证明此对象是可以被回收的。

**在Java中，可作为GC Roots对象的列表：**

- Java虚拟机栈中的引用对象。
- 本地方法栈中JNI（既一般说的Native方法）引用的对象。
- 方法区中类静态常量的引用对象。
- 方法区中常量的引用对象。

## 7. 对象生死与引用

### 7.1 引用关系

​		对象不是非生即死的，当空间还足够时，还可以保留这些对象，如果空间不足时，再抛弃这些对象。很多缓存功能的实现也符合这样的场景。强引用、软引用、弱引用、虚引用，这4种引用的强度是依次递减的。

#### 7.1.1 强引用（Strong Reference）

​		在代码中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

#### 7.1.2 软引用（Soft Reference）

​		是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当jvm认为内存不足时，才会去试图回收软引用指向的对象。jvm会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。

#### 7.1.3 弱引用（Weak Reference）

​		非必需对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。

#### 7.1.4 虚引用（Phantom Reference）

​		也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当着个对象被收集器回收时收到一条系统通知，即**主要用来跟踪对象被垃圾回收的活动**。

> ​		**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
>
> ​		在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

### 7.2 生死关系

​		在可达性算法中不可达的对象，并不是“非死不可”的，**要真正宣告一个对象死亡，至少要经历两次标记的过程**。如果对象在进行可达性分析之后，没有与GC Roots相连接的引用链，它会被第一次标记，并进行筛选，筛选的条件是此对象是否有必要执行finalize()方法。

- **执行finalize()方法的两个条件：**

  - 重写了finalize()方法。

  - finalize()方法之前没被调用过，因为对象的finalize()方法只能被执行一次。

    > 如果满足以上两个条件，这个对象将会放置在F-Queue的队列之中，并在稍后由一个虚拟机自建的、低优先级Finalizer线程来执行它。

- **对象的“自我拯救”：**

​		finalize()方法是对象脱离死亡命运最后的机会，如果对象在finalize()方法中重新与引用链上的任何一个对象建立关联即可，比如把自己（this关键字）赋值给某个类变量或对象的成员变量。

- **不建议使用finalize()方法来拯救对象：**
  - 对象的finalize()只能执行一次。
  - 它的运行代价高昂。
  - 不确定性大。
  - 无法保证各个对象的调用顺序。

## 8. 垃圾回收算法

### 8.1 标记-清除

​		标记-清除算法是最基础的算法，像它的名字一样算法分为“标记”和“清除”两个阶段，首先需要标记出所需要回收的对象，标记完成后统一收集被标记的对象。

**优点：** 实现简单。
**缺点：** 产生不连续的内存碎片；“标记”和“清除”的执行效率都不高。

### 8.2 复制

​		复制算法就是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。

**优点：** 执行效率高。
**缺点：** 空间利用率低， 因为复制算法每次只能使用一半的内存。

### 8.3 标记-整理

​		标记-整理算法采用和标记清除算法一样的对象“标记”，但后续不会对可回收对象进行清理，而是将存活的对象往一端空闲空间移动，然后清理边界以外的内存空间。

**优点：** 解决了内存碎片问题，比复制算法空间利用率高。
**缺点：** 因为有局部对象移动，相对效率不高。

### 8.4 分代收集

​		目前商用虚拟机都采用的是分代收集的算法，这种算法按照对象存活周期把内存分为几块，一般Java中分为新生代和老年代。把存活率低的对象分到**新生代使用复制算法提高垃圾回收的性能，老年代则存放存活率搞的对象，使用标记-清除和标记-整理的算法，提高内存空间使用率**。

## 9. 垃圾收集器

### 9.1 Serial 收集器

​		Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了，是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。

​		**新生代采用复制算法，老年代采用标记-整理算法。**

​		虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。

​		Serial 收集器优于其他垃圾收集器的地方在于**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。

### 9.2 ParNew 收集器

​		ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

​		**新生代采用复制算法，老年代采用标记-整理算法。**

​		它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。

> 并行和并发概念补充
>
> - **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
> - **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

### 9.3 Parallel Scavenge 收集器

​		Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 **那么它有什么特别之处呢？**

```
-XX:+UseParallelGC 

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行
```

​		**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。

​		**新生代采用复制算法，老年代采用标记-整理算法。** 

### 9.4 Serial Old 收集器

​		**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

### 9.5 Parallel Old 收集器

​		**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

### 9.6 CMS 收集器

​		**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，非常符合在注重用户体验的应用上使用，是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；**从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的。

- CMS收集器运作过程相比于前面几种垃圾收集器来说更加复杂一些，分为四个步骤：
  - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；

  - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

  - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

  - **并发清除：** 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

- CMS收集器主要优点：**并发收集、低停顿**，但是它有下面三个明显的缺点：
  - **对 CPU 资源敏感；**

  - **无法处理浮动垃圾；**

  - **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

### 9.7 G1 收集器

​		**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

- G1 收集器作为JDK1.7 中 HotSpot 虚拟机的一个重要进化特征，具备一下特点：
  - **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
  - **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
  - **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
  - **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

- G1 收集器的运作大致分为以下几个步骤：
  - **初始标记**
  - **并发标记**
  - **最终标记**
  - **筛选回收**

​		**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

## 10. 命令参数

java虚拟机启动时会带有很多的启动参数，Java命令本身就是一个多参数的启动命令。那么具体JVM启动包含哪些参数呢？

- 标准参数（Standard Option）
- 非标准参数（Non-Standard Options）
- 高级运行时参数（Advanced Runtime Options）
- 高级JIT编译器参数（Advanced JIT Compiler Options）
- 高级服务能力参数（Advanced Serviceability Options）
-  高级垃圾回收参数（Advanced Garbage Collection Options）

```shell
java [options] classname [args]
java [options] -jar filename [args]
```

### 标准参数（Standard Option）

**被所有JVM实现都要支持的参数。用于做一些常规的通用的动作，比如检查版本、设置classpath等。**

- -agentlib:libname[=options]

> 设置加载指定的native agent库。理论上这条option出现后，JVM会到本地固定路径下LD_LIBRARY_PATH这里加载名字为libxxx.so的库。而这样的库理论上是JVM TI的功能，具体可以参考JVM TI规范

- -agentpath:pathname[=options]

> 设置了从哪个绝对路径加载agent库。与-agentlib相同，只不过是用绝对路径来指明库文件。

- -client	-server

> 设置JVM的启动模式是client模式还是server模式，具体就是 Java HotSpot Client(Server) VM 版本。目前64位的JDK启动，一定是server模式，会忽略这个参数。

- -Dproperty=value

> 设置系统属性，设置后的属性可以在代码中System.getProperty方法获取到。

- -d32	-d64

> 设置JVM启动的环境模式，默认是32位启动，如果系统不支持，那么会报错，-d64模式和-server模式是绑定的，也就是说-d64声明了就默认是server模式。

- disableassertions[:[packagename]...|:classname]	-da[:[packagename]...|:classname]

> 关闭**指定**包或类下的assertion，默认是关闭的。

- -disablesystemassertions	-dsa

> 关闭**系统**包或类下的assertion。

- -enableassertions[:[packagename]...|:classname]	-ea[:[packagename]...|:classname]

>  开启**指定**包或类下的assertion。

- -enablesystemassertions	-esa

>  开启**系统**包或类下的assertion。

- -javaagent:jarpath[=options]

>  加载指定的java agent，具体需要传入jar路径。

- -verbose:class	-verbose:gc	-verbose:jni

> 都是用来展示信息的，class展示的每个class的信息，gc展示每个GC事件的信息，jni开启展示JNI调用信息。

- -version

> 显示版本信息，然后退出

### 非标准参数（Non-Standard Options）

**非标准参数主要是针对官方JVM也就是HotSpot的，当然各家自研的JVM也有自己的非标准参数。**

- -X

> 著名的-X参数，就是一个help，展示所有-X开头的参数说明。

- -Xbatch

> 禁止后台编译。将编译过程放到前台任务执行。JVM默认会将编译任务当做后台任务执行。这个参数等价于-XX:-BackgroundCompilation

- -Xfuture

> 强制class文件格式检查。

- -Xint

> 在 interpreted-only模式运行程序。编译为native的模式不再生效，所有的字节码都在解释器环境下解释执行。

- -Xinternalversion

> 打印一个更详细的java版本信息，执行后退出。

- -Xloggc:filename

> 设置gc日志文件，gc相关信息会重定向到该文件。这个配置如果和-verbose:gc同时出现，会覆盖-verbose:gc参数。比如-Xloggc:/home/admin/logs/gc.log

- -Xmaxjitcodesize=size

> 为JIT编译的代码设置最大的code cache。默认的设置是240m，如果关闭了tiered compilation，那么默认大小是48m。这个参数和-XX:ReservedCodeCacheSize是等价的。

- -Xmixed

> 用解释器执行所有的字节码，除了被编译为native code的hot method。

- -Xmnsize

> 设置初始最大的年轻代堆大小。比如-Xmn256m

- -Xmssize

> 设置初始的堆大小。

- -Xmxsize

> 设置最大的内存分配大小。一般的服务端部署，-Xms和-Xmx设置为同样大小。与-XX:MaxHeapSize具有同样的作用。具体设置参考[3]

- -Xnoclassgc

> 关闭对class的GC。这样设置可以节约一点GC的时间，不过带来的影响就是class永驻内存，不当的使用会导致OOM风险。

- -XshowSettings:category

> 查看settings信息，category可以是all、locale、properties和vm几部分。

- -Xsssize

> 设置thread stack大小，一般默认的几个系统参数如下：
>
> Linux/ARM (32-bit): 320 KB
>
> Linux/i386 (32-bit): 320 KB
>
> Linux/x64 (64-bit): 1024 KB
>
> OS X (64-bit): 1024 KB
>
> Oracle Solaris/i386 (32-bit): 320 KB
>
> Oracle Solaris/x64 (64-bit): 1024 KB

- -Xverify:mode

> 设置字节码校验器的模式，默认是remote，即只校验那些不是通过bootstrap类加载器加载的字节码。而还有一个模式还all，即全部都校验。虽然还有一个模式是none，但是本质上jvm不生效这个参数。因为字节码校验是非常重要的，如果关闭，将可能导致class文件格式就是错的，这对于系统稳定和安全来说有重大风险。
