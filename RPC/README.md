# RPC

​	对于RPC，我们经常可以看到伴随出现的一些其他名词，例如：RMI、HTTP、TCP、UDP、RestFul、SOAP，以及很火的Dubbo和Spring Cloud等等，名词越多关系越复杂，他们之间的关联是什么，之前的区别又是什么，学习中可能会遇见很多的坑，而且搜索到的很多博文并没有充分的理解各自之间的关系，所以对于这个问题接下的内容将进行一一解读。

| 层数 | 层名称         | 具体协议举例                                                 |
| ---- | -------------- | ------------------------------------------------------------ |
| 7    | **应用层**     | 例如：HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP 等 |
| 6    | **表示层**     | 例如：XDR、ASN.1、SMB、AFP、NCP 等                           |
| 5    | **会话层**     | 例如：ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets 等 |
| 4    | **传输层**     | 例如：TCP、UDP、RTP、SCTP、SPX、ATP、IL 等                   |
| 3    | **网络层**     | 例如：IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25  等 |
| 2    | **数据链路层** | 例如：以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP 等 |
| 1    | **物理层**     | 例如：线路、无线电、光纤、信鸽 等                            |

##RPC & RMI

**RPC** ，**Remote Procedure Call [远程过程调用]**。

​	**远程过程调用**的目的是用于不同服务器之间服务的请求和响应。**让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。**

**RMI** ，**Remote Method Invocation [远程方法调用]**。

​	RMI需要与特定的Java RMI要进行区分 ，**RMI**的目的同样是用于不同服务器之间服务的请求和响应，与**RPC**最大区别在于使用了面向对象的概念，也可以说成RMI就是一个典型的RPC实现。在远程调用时可以把对象应用作为参数传递，并通过传递的对象调用远程的服务，它的实现最典型的就是Java RMI，但不限于Java RMI。

###远程调用的出现

​	其实这是应用开发到一定的阶段的强烈需求驱动的。

1. 如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着；
2. 当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个**互不关联的应用**，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。
3. 当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经**不能简单划分开来或者划分不出来**。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 交互，以此来完成完整的业务功能。所以此时，我们急需**一种高效的应用程序之间的通讯手段**来完成这种需求，所以你看，RPC大显身手的时候来了！

​	其实3描述的场景也是**服务化 、微服务** 和**分布式系统架构** 的基础场景。即RPC框架就是实现以上结构的有力方式。

### 核心点

- 网络传输透明

​	既然客户端认为自己是在调用本地对象。那么网络传输中使用的是TCP/UDP还是HTTP协议，又或者是一些其他的协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。

- 数据封装透明

​	本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。对于远程调用，被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的，并且这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。

- 跨语言能力

​	调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。

​	**RPC**有能力支持跨语言性，**RMI**不支持跨语言性。

### 交互协议

​	远程调用允许客户端透明地调用不同服务器程序中的过程，而无须关心远程通信中的各个细节。但是这些服务器程序一般存在于不同的进程中，并且存在于不同的客户端计算机中。如果要完成远程调用，必然要设计出一种协议让客户端和服务端来遵守，这样才能让调用者和提供调用过程者协同完成工作。其实我们对这种“协议”也不陌生，比如熟知的TCP/IP协议和Http 协议等等，而对于Java RMI，则使用JRMP [Java Remote Method Protocol] 进行通信，这个协议类似于HTTP协议，都是建立在 TCP/IP上的应用层协议。

​	**在远程调用过程中有多种交互协议**，具体如下：

| 协议               | 客户端 | 服务端 | 客户端   | 说明                                                         |
| ------------------ | ------ | ------ | -------- | ------------------------------------------------------------ |
| 请求协议           | 请求   | XX     | XX       | 可以用在不需要从远程操作中返回值或者客户端不需要得到远程操作执行确认的场景中，请求发送后客户端不需要等待应答消息而可以继续执行。 |
| 请求-应答协议      | 请求   | 应答   | XX       | 这种方式使我们最常见的，服务器的应答消息可以看做是客户端请求消息的一个确认。 |
| 请求-应答-确认协议 | 请求   | 应答   | 确认应答 | 比请求-应答协议多一个客户端的确认应答。                      |

> **在请求-应答协议中消息可以是同步的也可以是异步的**。

- 同步：来自服务器的应答到达客户端之前客户端的进程是阻塞的。
- 异步：可以使用在客户端允许服务端返回的结果有延迟的情况下，可以避免客户端进程的堵塞，但是如果服务端执行完则可以通过回调的方式来通知客户端执行结果。

【此处需要补充一些常见协议及其说明，例如常见的HTTP和TCP的关联，需要注意的坑，一个短连接，一个长连接，连接不一样，长连接就会涉及到连接心跳，建立连接数量的内容】

### 数据封装

​	客户端代理在发起调用前需要对调用信息进行编码，这就要考虑需要编码些什么信息并以什么格式传输到服务端才能让服务端完成调用。出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）。

​	毕竟是远程通信，需要将编码后的数据序列化成二进制流进行传输，序列化我们关心三个方面，不过这三点有时是鱼与熊掌不可兼得。

- 序列化和反序列化的效率，越快越好。
- 序列化后的字节长度，越小越好。
- 序列化和反序列化的兼容性，接口参数对象若增加了字段，是否兼容。

> 我们通过典型的RPC框架来说明常见的数据封装。

- JAVA RMI：见下方Java RMI数据封装详解。
- GRPC：基于ProtoBuf(Protocol Buffers)序列化协议。
- Thrift：消息格式采用私有的二进制流格式和一种LVQ（类似于TLV消息格式）的消息格式，以及常规的JSON格式。
- Hetty：消息格式采用私有的二进制流格式。
- Dubbo：消息格式采用私有的二进制流格式。但是需要注意Dubbo是分布式服务治理框架，以及SOA治理方案，不是简单的RPC框架。
- Spring Cloud：消息格式基于HTTP协议对消息的封装。同样需要注意Spring Cloud是分布式服务治理框架，提供构建微服务所需的所有解决方案，不是简单的RPC框架。
- 其他的RPC框架：基于RPC的定义，Xfire，CXF这些Web Service框架也属于RPC，XML是它们的消息格式。

​	选择或者定义一种消息格式的封装，要考虑的问题包括：消息的易读性、描述单位内容时的消息体大小、编码难度、解码难度、解决半包/粘包问题的难易度。当然如果只是想定义一种RPC专用的消息格式，那么消息的易读性可能不是最需要考虑的。**消息封装格式的设计是目前各种RPC框架性能差异的最重要原因**，这就是为什么几乎所有主流的RPC框架都会设计私有的消息封装格式的原因。

### 远程对象发现

​	在调用远程对象的方法之前需要一个远程对象的引用，如何获得这个远程对象的引用在RMI中是一个关键的问题。将远程对象的发现类比于IP地址的发现可能比较好理解一些。

​	日常使用网络时，基本上都是通过域名来定位一个网站，但是实际上网络是通过IP地址来定位网站的，因此其中就需要一个映射的过程，域名系统（DNS）就是为了这个目的出现的，在域名系统中通过域名来查找对应的IP地址来访问对应的服务器。那么对应的，IP地址在这里就相当于远程对象的引用，而DNS则相当于一个IP地址的注册中心（Registry）。而域名在RMI中就相当于远程对象的标识符，客户端通过提供的远程对象的标识符访问注册中心，来得到远程对象的引用。

> 标识符是类似URL地址格式的，需要满足的规范如下：

- 该名称是URL形式的，类似于http的URL，schema是rmi；
- 格式类似于rmi://host:port/name，host指明注册表运行的注解，port表明接收调用的端口，name是一个标识该对象的简单名称。
- 主机和端口都是可选的，如果省略主机，则默认运行在本地；如果端口也省略，则默认端口是1099

​	我们现在回到RMI上来，RMI对服务器的IP地址和端口依赖很紧密，可能会出现在开发的时候不知道服务器IP和端口如何，但是客户端程序依赖这个IP和端口，人肉告知的方式变得麻烦和不现实，所以需要一套机制去解决服务注册和发现的问题，这就是为什么出现Eureka，Zookeeper这类服务注册发现技术，让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（IP + 端口）去访问具体的服务提供者。

### 错误处理

​	在远程过程调用时不可避免的会出现各种各样的问题，比如由于网络传输的问题导致的信息传递中断，或者当服务器出现故障时不能及时返回应答信息等等。

​	想想在发送Http请求时出现问题我们时会看到什么，网络错误！！Time Out！！通常就是几种方式。在远程调用时同样要考虑这种问题。这里使用超时这个错误情况来表述我们的解决方法：

- 直接将超时的信息抛给客户端调用者，由他来决定下一步干什么，但是这种方法太不“智能”了。

- 通过编程来实现，如果发生超时，进行重试，重试的次数和多长时间重试可以通过编程决定。

  **Tips：需要注意的是，服务器端对客户端所调用操作的处理时间和返回结果的时间总和大于我们在客户端设置的超时时间，就会产生重复发送请求消息的问题，执行该项请求已经消耗了大量时间，所以绝不能够再让服务器重复执行该操作，所以在服务端应该能够识别连续且来自同一个客户端的消息，并且过滤掉重复的消息。**

- 客户端通过异步的方式进行调用时，那么在客户端就不用考虑超时的问题了，请求消息和应答消息就有足够的时间进行传递，而当应答消息返回时，可以通过回调的方法来通知客户端，这种可以设计成基于事件的，但是这样做的前提是客户端对该应答消息的延迟有相当的容忍程度。

### **Java RMI**

​	Java RMI是RMI在Java上的实现，同样我们也从Java RMI的JRMP协议上入手。

#### 数据封装

​	我们都知道在 Java 程序中引用类型（不包括基本类型）的参数传递是按引用传递的，对于在同一个虚拟机中的传递时是没有问题的，因为的参数的引用对应的是同一个内存空间，但是对于分布式系统中，由于对象不再存在于同一个内存空间，虚拟机A中的对象引用对于虚拟机B没有任何意义，不是一块内存，那么怎么解决这个问题呢？

- 引用传递改为值传递

  ​	将引用传递改为值传递，也就是将对象序列化为字节，然后使用该字节的副本在客户端和服务器之间传递，而且一个虚拟机中对该值的修改不会影响到其他主机中的数据。

  ​	对象的序列化存在有一个问题，就是对象的嵌套引用就会造成序列化的嵌套，这必然会导致数据量的激增，因此我们需要有选择进行序列化，在 Java 中一个对象如果能够被序列化，需要满足几个条件。 

  1. 是Java的基本类型。
  2. 实现`java.io.Serializable`接口（String类即实现了该接口）。
  3. 对于容器类，如果其中的对象是可以序列化的，那么该容器也是可以序列化的；可序列化的类的子类也是可以序列化的。

- 仍然使用引用传递

  ​	每当远程主机调用本地主机方法时，该调用还要通过本地主机查询该引用对应的对象，在任何一台机器上的改变都会影响原始主机上的数据，因为这个对象是共享的。

**RMI 中的参数传递和结果返回可以使用的三种机制（取决于数据类型）**

- 简单类型：按值传递，直接传递数据拷贝。
- 远程对象引用（实现了`Remote`接口）：以远程对象的引用传递。
- 远程对象引用（未实现`Remote`接口）：按值传递，通过序列化对象传递副本，本身不允许序列化的对象不允许传递给远程方法。

### 总结

- RMI是面向对象的，RPC是面向过程的。
- RMI调用方法，RPC调用函数。
- RPC可以实现跨语言性，RMI不可以实现跨语言性。
- RPC是过时的，RMI是未来。

## RPC & Message

- 功能差异

  在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。

  - 消息的特点

    - Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。
    - Message Queue引入一下新的结点，系统的可靠性会受Message Queue结点的影响。
    - Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。

    **所以对于有同步返回需求，用Message Queue则变得麻烦了。**

  - RPC的特点

    - 如果以RPC的方式使用，对于要等待返回结果/处理结果的场景，由于等待结果，Consumer（Client）会有线程消耗。
    - 如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。

- 适用场合差异

  - 希望同步得到结果的场合，RPC合适。
  - 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用，但是异步的方式编程比较复杂。
  - 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。
  - 返回值是void的调用，因为实际上这个调用业务上往往不需要同步得到处理结果的，只要保证会处理即可，使用消息队列。

- 不适用场合说明

  - RPC同步调用使用Message Queue来传输调用信息。 发送端是在等待，同时占用一个中间点的资源。变得复杂了，但没有对等的收益。

 

